/**********************************************************
 *  Operant I/O library
 *  
 *  Copyright 2001 Donour Sizemore & University of Chicago
 *
 *  6-28-01 : Initial version completed.   
 *
 *  8-20-01 : Modified the library to work with BOTH comedi
 *            driver and Amish's ISA-DIO96 driver.  Is able
 *            to read and write with single bit granularity
 *            but it's ugly.
 **********************************************************/

#include "operantio.h"

#include <stdio.h>
#include <comedilib.h>
#include <stdlib.h>
#include <memory.h>
#include <unistd.h>

/* INPUT Chans (Basically just STUPID offsets) */ 
#define  IN_8      7
#define  IN_7      6
#define  IN_6      5
#define  IN_5      4
#define  IN_4      3
#define  IN_3      2
#define  IN_2      1
#define  IN_1      0

/* OUTPUT Chans (again) */
#define  OUT_8      7
#define  OUT_7      6
#define  OUT_6      5
#define  OUT_5      4
#define  OUT_4      3
#define  OUT_3      2
#define  OUT_2      1
#define  OUT_1      0


#define COMEDI_DEV  "/dev/comedi0"

comedi_t *operant_comedi_device=NULL; 


/* FD for Amish S. Dave's isa driver */
int asd_infd=0, asd_outfd = 0;
unsigned char asd_mask = 0; 
int operant_initialized=0;


/* Initialize box by selecting corresponding file discriptor 
 * This will overwrite the values of file discriptors if 
 * called more than once. 
 */
void operant_write(int, int , int);
int operant_init(int box_id)
{
  char *inname, *outname;
  //int i;
  if(box_id < 7 ){ /* Do amish driver stuff */
    switch (box_id)
      {
      case 1:
	inname = "/dev/dio96/portaa";
	outname = "/dev/dio96/portab";
	break;
      case 2:
	inname = "/dev/dio96/portac";
	outname = "/dev/dio96/portba";
	break;
      case 3:
	inname = "/dev/dio96/portbb";
	outname = "/dev/dio96/portbc";
	break;
      case 4:
	inname = "/dev/dio96/portca";
	outname = "/dev/dio96/portcb";
	break;
      case 5:
	inname = "/dev/dio96/portcc";
	outname = "/dev/dio96/portda";
	break;
      case 6:
	inname = "/dev/dio96/portdb";
	outname = "/dev/dio96/portdc";
	break;
      default:
	inname = outname = NULL;
      }
    if ((asd_infd = open(inname, O_RDONLY)) == -1)   /* open input port */
    {
      fprintf(stderr, "ERROR: Failed to open %s. ", outname);
      perror(NULL);
      exit(-1);
    }
    if ((asd_outfd = open(outname, O_WRONLY)) == -1) /* open output port */
      {
	fprintf(stderr, "ERROR: Failed to open %s. ", outname);
	perror(NULL);
	close(asd_infd);
	exit(-1);
      }
    write (asd_outfd,&asd_mask, 1);  

  }

  else  /* Do comedi stuff */
    {
      operant_comedi_device=comedi_open(COMEDI_DEV);
    }


  /*  for(i=0; i<7; i++)
    operant_write(box_id, i, 0);
    */
  operant_initialized=1;
  return 0;
}

void operant_clear(int box_id)
{
  int i;
  if(operant_initialized)
    for(i=0; i<7; i++)
      operant_write(box_id, i, 0);
  else
    printf("Attempted to clear box #%d without initializing\n", box_id);
}

void operant_close(int box_id)
{
  if (box_id < 7)
    {
      close(asd_infd);
      close(asd_outfd);
    }
  else
    comedi_close(operant_comedi_device);
}


/* This function contains the mappings of chan <--> cage */
int set_base_io_chans(int *indev, int *input, int *outdev, int *output, int cage)
{ 
  switch (cage)
    {
    case 0:
      *input  = 0;
      *output = 8;
      *indev  = 0;
      *outdev = 0;
      break;
    case 1:
      *input  = 16;
      *output = 0;
      *indev  = 0;
      *outdev = 1;
      break;
    case 2:
      *input  = 8;
      *output = 16;
      *indev  = 1;
      *outdev = 1;
      break;
    case 3:
      *input  = 0;
      *output = 8;
      *indev  = 2;
      *outdev = 2;
      break;
    case 4:
      *input  = 16;
      *output = 0;
      *indev  = 2;
      *outdev = 3;
      break;
    case 5:
      *input  = 8;
      *output = 16;
      *indev  = 3;
      *outdev = 3;
      break;
    default:
      printf("Error!: cage %d not valid\n", cage);
      *indev=*outdev=*input=*output=0;
      break;
    }
  return 0;
}


/* Output wrapper */
void operant_write(int box_id, int channel, int state)
{
  int indev, in, outdev,out;
  unsigned char bits=0;
  if(channel > 7 || channel <0)
    {
      printf("Channel #%d doesn't exist!\n", channel);
    }
  if(box_id < 7)  /* Use Amish's isa DIO96 driver */
    {
  
      /* Calculate new mask */
      bits = asd_mask;
      bits >>=channel;
      bits %=2;
      
      if(state)
	{
	  if(!bits)
	    {
	      bits = 1;
	      bits <<=channel;
	      asd_mask += bits;

	    }
	}
      else
	if(bits)
	  {
	    bits = 1;
	    bits <<=channel;
	    asd_mask -= bits;
	  }
      
      
      bits = ~asd_mask;
    //  printf("%x|| %x\n", bits, asd_mask);
      /* write new mask to device */
      write(asd_outfd,&bits , 1);

    }
  else            /* Use comedi driver */
    {
      box_id -= 7;
      set_base_io_chans(&indev, &in, &outdev, &out, box_id);
      
      if (state)
	comedi_dio_write(operant_comedi_device,outdev,(out-channel+7), 0);
      else
	comedi_dio_write(operant_comedi_device,outdev,(out-channel+7), 1);
    }
}

/* Input Wrapper */
int operant_read(int box_id, int channel)
{
  int indev, in, outdev,out;
  int bits=0;
  if(channel > 7 || channel <0)
    {
      printf("Channel #%d doesn't exist!\n", channel);
      return -1;
    }
  if(box_id < 7)  /* Use Amish's ISA driver */
    {
      /* read bit mask */
      read(asd_infd, &bits, 1);

      /* extract correct field */
      bits >>=channel;      
      bits %= 2;
      return !bits;
    }

  else            /* Use comedi driver */
    {
      box_id -= 7;

      set_base_io_chans(&indev, &in, &outdev, &out, box_id);
      comedi_dio_read(operant_comedi_device,indev,in-channel+7, &out );
      return !out;
    }
}














