/* 
8/10/08:EC
adapted from femx
plays 3-channel stereo sound stimuli
NOTE:requires three audio channels in a SINGLE DAC (see ALSA file asound.conf), cue lights
*/

#include <stdio.h>
#include <stdlib.h>
#include <sndfile.h>
#include <math.h>
#include <signal.h>
#include <sys/time.h>

#define ALSA_PCM_NEW_HW_PARAMS_API

#include <alsa/asoundlib.h>
#include "/usr/local/src/operantio/operantio.c"
#include <sunrise.h>

#define DEBUG 0
 
#define timeradd(a, b, result)                                                \
  do {                                                                        \
    (result)->tv_sec = (a)->tv_sec + (b)->tv_sec;                             \
    (result)->tv_usec = (a)->tv_usec + (b)->tv_usec;                          \
    if ((result)->tv_usec >= 1000000)                                         \
      {                                                                       \
        ++(result)->tv_sec;                                                   \
        (result)->tv_usec -= 1000000;                                         \
      }                                                                       \
  } while (0)
#define timersub(a, b, result)                                                \
  do {                                                                        \
    (result)->tv_sec = (a)->tv_sec - (b)->tv_sec;                             \
    (result)->tv_usec = (a)->tv_usec - (b)->tv_usec;                          \
    if ((result)->tv_usec < 0) {                                              \
      --(result)->tv_sec;                                                     \
      (result)->tv_usec += 1000000;                                           \
    }                                                                         \
  } while (0)


/* --- OPERANT IO CHANNELS ---*/ 
/* todo: redefine these channels: need hopper, cue lights */
#define L_PERCH 1
#define C_PERCH 2
#define R_PERCH 3 
#define HOUSELT	4    

/*----- AUDIO OUTPUT CHANNELS -----*/
#define TRIP_PCM "tripledac"

/* --------- OPERANT VARIABLES ---------- */
#define RESP_INT_SEC             1             /* seconds that bird must stay on the same perch to start playback (see below) */
#define RESP_INT_USEC            0             /* microsecs in the response window (added to above) */
#define MAXSTIM                  1024          /* maximum number of stimulus exemplars */ 
#define MAXCLASS                 256            /* maximum number of stimulus classes */   
#define INTER_TRIAL_INTERVAL     2.0           /* iti in seconds */
#define TDOFFSET                 0.5           /* offset between masker playback and target/distractor onset */
#define RESPONSE_SAMPLE_INTERVAL 500000        /* input polling rate in nanoseconds */
#define MAX_NO_OF_TRIALS         100000        /* maximum number of trials in block of sessions */
#define EXP_START_TIME           7             /* hour(0-24) session will start */
#define EXP_END_TIME             19            /* hour(0-24) session will stop */
#define SLEEP_TIME               30            /* night loop polling interval (in sec) */
#define STIMPATH       "/usr/local/stimuli/"
#define MAXFILESIZE         26460000           /*maximum nuber of samples in any soundfile: 10 min at 44.1kHz */

int  trial_max = MAX_NO_OF_TRIALS;
int  starthour = EXP_START_TIME; 
int  stophour = EXP_END_TIME;
int  stopmin = 0;
int  startmin = 0;
int  sleep_interval = SLEEP_TIME;
const char exp_name[] = "3SPK";
int box_id = -1;
int perch1=0, perch2=0, xperch=0;


struct timespec iti = {INTER_TRIAL_INTERVAL, 0};
struct timespec rsi = {0, RESPONSE_SAMPLE_INTERVAL};
struct timeval min_perch = {RESP_INT_SEC, RESP_INT_USEC};

struct PERCH{
  int perch1;
  int perch2;
  int xperch;
} trial;

snd_pcm_t *pcm_trip,*aud1, *aud2, *xaud;
unsigned int channels = 3;                      /* count of channels on a single DAC*/
unsigned int rate = 44100;                      /* stream rate */
snd_pcm_format_t format = SND_PCM_FORMAT_S16;   /* sample format */
unsigned int buffer_time = 500000;              /* ring buffer length in us */
unsigned int period_time = 100000;              /* period time in us */
int resample = 1;                               /* enable alsa-lib resampling */
int period =0;

snd_pcm_sframes_t buffer_size;
snd_pcm_sframes_t period_size;
snd_output_t *output = NULL;

/* -------- Signal handling --------- */
int client_fd = -1;
static void sig_pipe(int signum)
{ fprintf(stdout,"SIGPIPE caught\n"); client_fd = -1;}
static void termination_handler (int signum){
  snd_pcm_close(pcm_trip);
  fprintf(stdout,"closed pcm devices: term signal caught: exiting\n");
  exit(-1);
}

/*********************************************************************************
 * PCM SETUP 
 ********************************************************************************/
snd_pcm_t *do_setup(char *pcm_name)
{
  snd_pcm_t *handle;
  snd_pcm_hw_params_t *params;
  snd_pcm_access_t access = SND_PCM_ACCESS_RW_INTERLEAVED;
  snd_pcm_sw_params_t *swparams;
  unsigned int rrate;
  int err, dir;
  snd_pcm_uframes_t persize;
  snd_pcm_stream_t stream = SND_PCM_STREAM_PLAYBACK;
  
  snd_pcm_hw_params_alloca(&params);
  snd_pcm_sw_params_alloca(&swparams);

  /*open the pcm device*/
  if ((err = snd_pcm_open(&handle, pcm_name, stream, 0)) < 0) {
    printf("FATAL ERROR IN do_setup: Playback open error: %s\n", snd_strerror(err));
    exit (-1);
  }
  /* choose all parameters */
  err = snd_pcm_hw_params_any(handle, params);
  if (err < 0) {
    printf("FATAL ERROR IN do_setup: Broken configuration for playback: no configurations available: %s\n", snd_strerror(err));
    exit (-1);
  }
  /* set the interleaved read/write format */
  err = snd_pcm_hw_params_set_access(handle, params, access);
  if (err < 0) {
    printf("FATAL ERROR IN do_setup: Access type not available for playback: %s\n", snd_strerror(err));
    exit(-1);
  }
  /* set the sample format */
  err = snd_pcm_hw_params_set_format(handle, params, format);
  if (err < 0) {
    printf("FATAL ERROR IN do_setup: Sample format not available for playback: %s\n", snd_strerror(err));
    exit(-1);
  }
  /* set the count of channels */
  err = snd_pcm_hw_params_set_channels(handle, params, channels);
  if (err < 0) {
    printf("FATAL ERROR IN do_setup: Channels count (%i) not available for playbacks: %s\n", channels, snd_strerror(err));
    exit (-1);
  }
  /* set the stream rate */
  rrate = rate;
  err = snd_pcm_hw_params_set_rate_near(handle, params, &rrate, 0);
  if (err < 0) {
    printf("FATAL ERROR IN do_setup: Rate %iHz not available for playback: %s\n", rate, snd_strerror(err));
    exit(-1);
  }
  if (rrate != rate) {
    printf("FATAL ERROR IN do_setup: Rate doesn't match (requested %iHz, get %iHz)\n", rate, err);
    exit(-1);
  }
  /* set the buffer time */
  err = snd_pcm_hw_params_set_buffer_time_near(handle, params, &buffer_time, &dir);
  if (err < 0) {
    printf("FATAL ERROR IN do_setup: Unable to set buffer time %i for playback: %s\n", buffer_time, snd_strerror(err));
    exit(-1);
  }
  err = snd_pcm_hw_params_get_buffer_size(params, &buffer_size);
  if (err < 0) {
    printf("FATAL ERROR IN do_setup: Unable to get buffer size for playback: %s\n", snd_strerror(err));
    exit (-1);
  }
  if(DEBUG){printf("buffer size is %d\n", (int)buffer_size);}  
  /* set the period time */
  err = snd_pcm_hw_params_set_period_time_near(handle, params, &period_time, &dir);
  if (err < 0) {
    printf("FATAL ERROR IN do_setup: Unable to set period time %i for playback: %s\n", period_time, snd_strerror(err));
    exit(-1);
  }
  err = snd_pcm_hw_params_get_period_size(params, &period_size, &dir);
  if (err < 0) {
    printf("FATAL ERROR IN do_setup: Unable to get period size for playback: %s\n", snd_strerror(err));
    exit(-1);
  }
  if(DEBUG){printf("period size is %d\n", (int)period_size);}  
  /* write the parameters to device */
  err = snd_pcm_hw_params(handle, params);
  if (err < 0) {
    printf("FATAL ERROR IN do_setup: Unable to set hw params for playback: %s\n", snd_strerror(err));
    exit(-1);
  }

  /* --------- set up software parameters ---------*/ 
  /* get the current swparams */
  err = snd_pcm_sw_params_current(handle, swparams);
  if (err < 0) {
    printf("FATAL ERROR IN do_setup: Unable to determine current swparams for playback: %s\n", snd_strerror(err));
    exit(-1);
  }
  /* start the transfer when the buffer is almost full: */
  err = snd_pcm_sw_params_set_start_threshold(handle, swparams, (buffer_size / period_size) * period_size);
  if (err < 0) {
    printf("FATAL ERROR IN do_setup: Unable to set start threshold mode for playback: %s\n", snd_strerror(err));
    exit(-1);
  }
  /* allow the transfer when at least period_size samples can be processed */
  err = snd_pcm_sw_params_set_avail_min(handle, swparams, period_size);
  if (err < 0) {
    printf("FATAL ERROR IN do_setup: Unable to set avail min for playback: %s\n", snd_strerror(err));
    exit(-1);
  }
  /* align all transfers to 1 sample */
  err = snd_pcm_sw_params_set_xfer_align(handle, swparams, 1);
  if (err < 0) {
    printf("FATAL ERROR IN do_setup: Unable to set transfer align for playback: %s\n", snd_strerror(err));
    exit(-1);
  }
  /* write the parameters to the playback device */
  err = snd_pcm_sw_params(handle, swparams);
  if (err < 0) {
    printf("FATAL ERROR IN do_setup: Unable to set sw params for playback: %s\n", snd_strerror(err));
    exit(-1);
  }

  snd_pcm_hw_params_get_period_size (params, &persize, &dir);
  if(DEBUG){printf("done with setup\n");}
  period=persize;
  return handle;

}

/*****************************************************************************
 *   PLAYBACK UTILITIES:Underrun and suspend recovery
 *                      wait_for_poll
 *****************************************************************************/
static int xrun_recovery(snd_pcm_t *handle, int err)
{
  if (err == -EPIPE) {    /* under-run */
    err = snd_pcm_prepare(handle);
    if (err < 0)
      printf("Can't recovery from underrun, prepare failed: %s\n", snd_strerror(err));
    return 0;
  } else if (err == -ESTRPIPE) {
    while ((err = snd_pcm_resume(handle)) == -EAGAIN)
      sleep(1);       /* wait until the suspend flag is released */
    if (err < 0) {
      err = snd_pcm_prepare(handle);
      if (err < 0)
	printf("Can't recovery from suspend, prepare failed: %s\n", snd_strerror(err));
    }
    return 0;
  }
  return err;
}
static int wait_for_poll(snd_pcm_t *handle, struct pollfd *ufds, unsigned int count)
{
  unsigned short revents;
  while (1) {
    poll(ufds, count, -1);
    snd_pcm_poll_descriptors_revents(handle, ufds, count, &revents);
    if (revents & POLLERR)
      return -EIO;
    if (revents & POLLOUT)
      return 0;
  }
}

/*****************************************************************************
 *   Get soundfile info and verify formats
 *****************************************************************************/
int verify_soundfile(char *sfname)
{
  SNDFILE *sf;
  SF_INFO *sfinfo; 
  long unsigned int duration;

  sfinfo = (SF_INFO *) malloc(sizeof(SF_INFO));
    
  if(!(sf = sf_open(sfname,SFM_READ,sfinfo))){
    fprintf(stderr,"error opening input file %s\n",sfname);
    free(sfinfo);
    return -1;
  }

 /*print out some info about the file you just openend */
 if(DEBUG){
   printf(" ---------- Stimulus parameters ------------ \n");
   printf ("Samples : %d\n", (int)sfinfo->frames) ;
   printf ("Sample Rate : %d\n", sfinfo->samplerate) ;
   printf ("Channels    : %d\n", sfinfo->channels) ;
 }
  
  /* check that some assumptions are met */
  /* this should be done by the operant code*/
  if (sfinfo->frames > MAXFILESIZE){
    fprintf(stderr,"File is too large!\n");
    sf_close(sf);free(sfinfo);return -1;
  }
  if (sfinfo->samplerate != 44100){
    fprintf(stderr, "Sample rate for %s is not equal to 44.1 KHz!\n", sfname);
    sf_close(sf);free(sfinfo);return -1;
  }
  if (sfinfo->channels != 1){
    fprintf(stderr, "Sound file %s is not mono!\n", sfname);
    sf_close(sf);
    free(sfinfo);
    return -1;
    }
  /* make sure format is WAV */
  if((sfinfo->format & SF_FORMAT_TYPEMASK) != SF_FORMAT_WAV){
    printf("Not a WAV file\n");
    sf_close(sf);
    free(sfinfo);
    return -1;
  }
  duration = sfinfo->frames/44.1;
  free(sfinfo);
  if(DEBUG){printf("duration from soundfile verify:%lu\n",duration);}
  return (duration);

}

/**************************************************************************************
 * OUTPUT SOUND
 * extract a stimulus from the soundfile, output sound to a pcm(handle). 
 * this play will watch the perch during playback and abort if bird leaves the target perch
 * returns -1 on playback error, 1 for success
 **************************************************************************************/
int play_3stereo(snd_pcm_t *handle, char *maskname, char *targname, char *distname, int *playcase, int *box_id, int *noieslength)

     /* todo in main: get playcase, int 1:9, 1 if both R, 2 both L, 3 TR DL, 4 TL DR, 5 both C, 6 TR DC, 7 TC DL, 8 DR TC, 9 DC TL */
     /* todo: figure out how to handle mask = noise vs mask = TORC */
{
  float ramp_time = 0.05;  /*onset offset ramp duration in secs */
  int n_speak = 3;
  SNDFILE *sf;
  SF_INFO *sfinfo;
  short *obuff, *obuffm, *obufft, *obuffd, *obuffR, *obuffC, *obuffL;
  unsigned short *ptr;
  sf_count_t incount;
  double inframes, inframesm, inframesd, inframest, maxframes;
  int tmp;
  snd_pcm_uframes_t outframes, totframesout;
  int i, err, count, init;
  int ramp_dur=0;
  int offset = TDOFFSET;
  int masksr, targsr, distsr;
  int paddur;
  int fs = 44100;

  struct pollfd *ufds;

  /* memory for SF_INFO structures */
  sfinfo = (SF_INFO *) malloc(sizeof(SF_INFO));
 
  /* open input files*/
  /* open masker */
  if (strncmp('noise',maskname) == 0){
    /* todo: create noise masker */
    obuffm = 
    masksr = fs;
    inframesm = fs*noiselength;
  }
  else {
    if(!(sf = sf_open(maskname,SFM_READ,sfinfo))){
      fprintf(stderr,"error opening input file %s\n",maskname);
      free(sfinfo);
      return -1;
    }
    masksr= sfinfo ->samplerate;
    inframesm = (int)sfinfo->frames;
    obuffm = (short *) malloc(sizeof(int)*inframesm);
    if(DEBUG==3){printf("trying to sf_readf %d frames\n",(int)inframesm);}
    incount = sf_readf_short(sf, obuffm, inframesm);
    if(DEBUG==3){printf("got %d samples when I tried for %d from sf_readf_short()\n",(int)incount, (int)inframesm);}
  
  /* ramp the first (and last) 50 ms from zero to normal amplitude*/
  ramp_dur= ramp_time * masksr; //get number of samples for ramp
  for (i = 0; i<ramp_dur; i++)
    obuffm[i] = obuffm[i]*((float)i/(float)ramp_dur);
  for (i = (incount-ramp_dur); i<=incount; i++) 
    obuffm[i] = obuffm[i]* ((float)(incount-i)/(float)ramp_dur);
  
  /* open target */
  inframes=incount=ramp_dur=ramp_time=0;
  sf=[];
  if(!(sf = sf_open(targname,SFM_READ,sfinfo))){
    fprintf(stderr,"error opening input file %s\n",targname);
    free(sfinfo);
    return -1;
  }
  targsr=sfinfo->samplerate;
  if(targsr != masksr){
    fprintf(stderr, "error: masker and target have different sample rates");
    free(sfinfo);
    return -1;
  }
  inframest = (int)sfinfo->frames;
  if((inframest+offset*targsr) > inframesm){
    fprintf(stderr, "error: target + offset is longer than masker");
    free(sfinfo);
    return -1;
  }
  obufft = (short *) malloc(sizeof(int)*inframes);
  if(DEBUG==3){printf("trying to sf_readf %d frames\n",(int)inframest);}
  incount = sf_readf_short(sf, obufft, inframest);
  if(DEBUG==3){printf("got %d samples when I tried for %d from sf_readf_short()\n",(int)incount, (int)inframest);}
  
  /* ramp the first (and last) 50 ms from zero to normal amplitude*/
  ramp_dur= ramp_time * targsr; //get number of samples for ramp
  for (i = 0; i<ramp_dur; i++)
    obufft[i] = obufft[i]*((float)i/(float)ramp_dur);
  for (i = (incount-ramp_dur); i<=incount; i++) 
    obufft[i] = obufft[i]* ((float)(incount-i)/(float)ramp_dur);
 
  /* open distractor */
  incount=ramp_dur=ramp_time=0;
  sf=[];
  if(!(sf = sf_open(distname,SFM_READ,sfinfo))){
    fprintf(stderr,"error opening input file %s\n",distname);
    free(sfinfo);
    return -1;
  }
  distsr=sfinfo->samplerate;
  if(distsr != masksr){
    fprintf(stderr, "error: masker and distractor have different sample rates");
    free(sfinfo);
    return -1;
  }
  inframesd = (int)sfinfo->frames;
  if (inframesd != inframest){
    fprintf(stderr, "error: target and distractor have different lengths");
    free(sfinfo);
    return -1;
  }

  obuffd = (short *) malloc(sizeof(int)*inframesd);
  if(DEBUG==3){printf("trying to sf_readf %d frames\n",(int)inframesd);}
  incount = sf_readf_short(sf, obuffd, inframesd);
  if(DEBUG==3){printf("got %d samples when I tried for %d from sf_readf_short()\n",(int)incount, (int)inframesd);}
  
  /* ramp the first (and last) 50 ms from zero to normal amplitude*/
  ramp_dur= ramp_time * distsr; //get number of samples for ramp
  for (i = 0; i<ramp_dur; i++)
    obuffd[i] = obuffd[i]*((float)i/(float)ramp_dur);
  for (i = (incount-ramp_dur); i<=incount; i++) 
    obuffd[i] = obuffd[i]* ((float)(incount-i)/(float)ramp_dur);

  /* combine individual buffers into obuff */
  obuffR = (short *) malloc(sizeof(int)*inframesm);
  obuffC = (short *) malloc(sizeof(int)*inframesm);
  obuffL = (short *) malloc(sizeof(int)*inframesm);
  obuff = (short *) malloc(sizeof(int)*(n_speak*inframesm);
  obuffR = obuffC = obuffL = obuffm;
  paddur = offset * masksr;

  switch (playcase)
    {
    case 1: /* TR DR */
      for (i=0; i<inframest; i++){
	obuffR[i+paddur] = obuffR[i+paddur] + obufft[i] + obuffd[i];
      }
      break;

    case 2: /* TL DL */
      for (i=0; i<inframest; i++){
	obuffL[i+paddur] = obuffL[i+paddur] + obufft[i] + obuffd[i];
      }
      break;

    case 3: /* TR DL */
      for (i=0; i<inframest; i++){
	obuffR[i+paddur] = obuffR[i+paddur] + obufft[i];
      }
      for (i=0; i<inframest; i++){
	obuffL[i+paddur] = obuffL[i+paddur] + obuffd[i];
      }
      break;

    case 4: /* TL DR */
      for (i=0; i<inframest; i++){
	obuffL[i+paddur] = obuffL[i+paddur] + obufft[i];
      }
      for (i=0; i<inframest; i++){
	obuffR[i+paddur] = obuffR[i+paddur] + obuffd[i];
      }
      break;
    case 5: /* TC DC */
      for (i=0; i<inframest; i++){
	obuffC[i+paddur] = obuffC[i+paddur] + obufft[i] + obuffd[i];
      }
      break;

    case 6: /* TR DC */
      for (i=0; i<inframest; i++){
	obuffR[i+paddur] = obuffR[i+paddur] + obufft[i];
      }
      for (i=0; i<inframest; i++){
	obuffC[i+paddur] = obuffC[i+paddur] + obuffd[i];
      }
      break;

    case 7: /* TC DL */
      for (i=0; i<inframest; i++){
	obuffC[i+paddur] = obuffC[i+paddur] + obufft[i];
      }
      for (i=0; i<inframest; i++){
	obuffL[i+paddur] = obuffL[i+paddur] + obuffd[i];
      }

      break;

    case 8: /* TC DR */
      for (i=0; i<inframest; i++){
	obuffC[i+paddur] = obuffC[i+paddur] + obufft[i];
      }
      for (i=0; i<inframest; i++){
	obuffR[i+paddur] = obuffR[i+paddur] + obuffd[i];
      }
      break;

    case 9: /* TL DC */
      for (i=0; i<inframest; i++){
	obuffL[i+paddur] = obuffL[i+paddur] + obufft[i];
      }
      for (i=0; i<inframest; i++){
	obuffC[i+paddur] = obuffC[i+paddur] + obuffd[i];
      }
      break;

    default:
      /* print error */
      fprintf(stderr,"case type must be int 1:9, case=%d\n", playcase);
      break;
    }
  

  for (i=0; i<(n_speak*inframesm); n_speak){ /* not sure if i can do this in C */
    for (j=0; j<inframesm; j++){
    obuff[i] = obuffR[j];
    obuff[i+1] = obuffC [j];
    obuff[i+2] = obuffL [j];
    }
  }
  
  outframes = inframesm * n_speak;
  if(DEBUG==3){printf("I'll try to write %d frames\n", (int)outframes);}

  /* prepare audio interface */
    if (snd_pcm_prepare (handle) < 0) {
    fprintf (stderr, "cannot prepare audio interface for use\n");
    sf_close(sf);
    free(sfinfo);
    return -1;
  }
  
  snd_pcm_nonblock(handle,1); /*make sure you set playback to non-blocking*/

  /*playback with polling*/
  count = snd_pcm_poll_descriptors_count (handle);
  if (count <= 0) {
    printf("Invalid poll descriptors count\n");
    return count;
  }
  ufds = malloc(sizeof(struct pollfd) * count);
  if (ufds == NULL) {
    printf("Not enough memory\n");
    return -ENOMEM;
  }
  if ((err = snd_pcm_poll_descriptors(handle, ufds, count)) < 0) {
    printf("Unable to obtain poll descriptors for playback: %s\n", snd_strerror(err));
    return err;
  }
  init = 1;
  if (!init) {
    err = wait_for_poll(handle, ufds, count);
    if (err < 0) {
      if (snd_pcm_state(handle) == SND_PCM_STATE_XRUN ||
	  snd_pcm_state(handle) == SND_PCM_STATE_SUSPENDED) {
	err = snd_pcm_state(handle) == SND_PCM_STATE_XRUN ? -EPIPE : -ESTRPIPE;
	if (xrun_recovery(handle, err) < 0) {
	  printf("Write error: %s\n", snd_strerror(err));
	  exit(EXIT_FAILURE);
	}
	init = 1;
      } else {
	printf("Wait for poll failed\n");
	return err;
      }
    }
  }
  totframesout=0;
  ptr=obuff;

  /*start the actual playback*/
  while ( (outframes > 0) && (operant_read(box_id, tperch)) ) {
    err = snd_pcm_writei(handle,ptr, outframes);
    if (err < 0) {
      if (xrun_recovery(handle, err) < 0) {
	printf("Write error: %s\n", snd_strerror(err));
	exit(EXIT_FAILURE);
      }
      init = 1;
      break;  /* skip one period */
    }
    if (snd_pcm_state(handle) == SND_PCM_STATE_RUNNING)
      init = 0;

    totframesout += err; 
    ptr += err * channels;
    outframes -= err;
    /* if(DEBUG){printf("outframes is now %d\n", (int) outframes);}*/
    if (outframes == 0){
      if(DEBUG){printf("outframes is zero so I'll break\n");}
      break;
    }
    /* it is possible, that the initial buffer cannot store */
    /* all data from the last period, so wait a while */
    err = wait_for_poll(handle, ufds, count);
    if (err < 0) {
      if (snd_pcm_state(handle) == SND_PCM_STATE_XRUN ||
	  snd_pcm_state(handle) == SND_PCM_STATE_SUSPENDED) {
	err = snd_pcm_state(handle) == SND_PCM_STATE_XRUN ? -EPIPE : -ESTRPIPE;
	if (xrun_recovery(handle, err) < 0) {
	  printf("Write error: %s\n", snd_strerror(err));
	  exit(EXIT_FAILURE);
	}
	init = 1;
      } else {
	printf("Wait for poll failed\n");
	return err;
      }
    }
  }
  if(DEBUG==3){
    printf("exited while writei loop, so what am I waiting for?\n");
    printf("frames not played: %d \n", (int)outframes);
    printf("frames played: %d \n", (int) totframesout);
  }
  
  sf_close(sf);
  free(sfinfo);
  sfinfo=NULL;
  free(obuff);
  obuff=NULL;
  free(obuffm);
  obuffm=NULL;
  free(obufft);
  obufft=NULL;  
  free(obufft);
  obufft=NULL;
  free(obuffd);
  obuffd=NULL;
  free(obuffR);
  obuffR=NULL;
  free(obuffC);
  obuffC=NULL;
  free(obuffL);
  obuffL=NULL;
  free(ufds);
  ufds=NULL;
  return 1; /*successful playback*/
}


/**********************************************************************
 **********************************************************************/
void do_usage()
{
  fprintf(stderr, "3spk usage:\n");
  fprintf(stderr, "    3spk [-help] [-B int] [-n int] [-on int:int] [-off int:int] [-S int] <filename>\n\n");
  fprintf(stderr, "        -help          = show this help message\n");
  fprintf(stderr, "        -B int         = must be '-B 1' unless you change the DACs\n");
   fprintf(stderr, "       -on int:int    = set hour:min for exp to start eg: '-on 7:30' (default is 7:00 AM)\n");
  fprintf(stderr, "        -off int:int   = set hour for exp to stop eg: '-off 19:45' (default is 7:00 PM)\n");
  fprintf(stderr, "                         To use daily sunset or sunrise times use '-on 99' and/or '-off 99'\n");
  fprintf(stderr, "        -n int         = noise length in seconds. Required if masker is noise created online\n");
  fprintf(stderr, "        -swap int      = set the number of trials between stim-resp swap\n");
  fprintf(stderr, "                         use '-1' to never swap(default), '0' to swap each session\n");
  fprintf(stderr, "        -S int         = specify the subject ID number (required)\n");
  fprintf(stderr, "        filename       = specify the name of the text file containing the stimuli (required)\n");
  fprintf(stderr, "                         where each line is: 'Class' 'Wavfile' 'Cue' 'Present_freq'\n");
  fprintf(stderr, "                         'Class'= 1 for masker or 2 for target/distractor ");
  fprintf(stderr, "                         'Wavfile' is the name of the stimulus soundfile ( must be 44.1KHz)\n");
  fprintf(stderr, "                         if masker is online white noise, 'Wavfile' should simply be 'noise'\n");
  fprintf(stderr, "                         'cue' is either wav file (if auditory) or RED GRN BLU (if visual)\n");
  fprintf(stderr, "                         'Presfreq' is the overall rate at which the stimulus is presented.\n"); 
  fprintf(stderr, "                           The actual rate for each stimulus is presfreq divded by the\n");
  fprintf(stderr, "                           sum for all stims. Set all prefreq values to 1 for equal probablility \n"); 
  exit(-1);
}

/**********************************************************************
 ** parse the command line
 **********************************************************************/
int command_line_parse(int argc, char **argv, int *box_id, int *subjectid, int *starthour, int *stophour,int *startmin, int *stopmin, int *noiselength, int *swapval, char **stimfname)
{
  int i=0;
  if(DEBUG)printf("argc is %d\n", argc);
  
  if(argc>1){
    for (i = 1; i < argc; i++){
      if(DEBUG){fprintf(stderr, "argv[%d] was: %s\n", i, argv[i]);}
      if (*argv[i] == '-'){
	if (strncmp(argv[i], "-B", 2) == 0) 
	  sscanf(argv[++i], "%i", box_id);
	else if (strncmp(argv[i], "-S", 2) == 0)
	  sscanf(argv[++i], "%i", subjectid);
	else if (strncmp(argv[i], "-on", 3) == 0){
	  sscanf(argv[++i], "%i:%i", starthour,startmin);}
	else if (strncmp(argv[i], "-off", 4) == 0){
	  sscanf(argv[++i], "%i:%i", stophour, stopmin);}
	else if (strncmp(argv[i], "-n", 2) == 0)
	  sscanf(argv[++i], "%i", noiselength);
	else if (strncmp(argv[i], "-swap", 5) == 0)
	  sscanf(argv[++i], "%i", swapval);
	else if (strncmp(argv[i], "-help", 5) == 0){
	  do_usage();
	}
	else{
	  fprintf(stderr, "Unknown option: %s\t", argv[i]);
	  fprintf(stderr, "Try '3spk -help'\n");
	}
      }
      else
	*stimfname = argv[i];
    }
  }
  else
    do_usage();
  return 1;
}


/**********************************************************************
 **  main
**********************************************************************/
int main(int argc, char *argv[])
{
  FILE *stimfp = NULL, *datafp = NULL, *dsumfp = NULL;
  char *stimfname = NULL;
  char *stimfroot, fullsfname[256], fullcfname[256];
  const char delimiters[] = " .,;:!-";
  char datafname[128], hour [16], min[16], month[16], year[16], 
    day[16], dsumfname[128], stimftemp[128];
  char  buf[128], stimexm[128],fstim[256],temphour[16],tempmin[16],
    timebuff[64], tod[256], date_out[256], buffer[30];
  int nclasses, nstims, stim_class, C2t_stim_number, C2d_stim_number, C1_stim_number, stim_reinf,offstep1,offstep2,
    stepval,subjectid, num_c1stims, num_c2stims,stimdurtest,swapval=-1,rswap,swapcnt,
    initstate=-1,trial_num,session_num,C2t_pval,C2d_pval,C1_pval,i,j,k,*C2_plist=NULL,*C1_plist=NULL,mapval=-1,
    tot_c1stims=0, tot_c2stims=0,dosunrise=0,dosunset=0,starttime,stoptime,currtime,stim_num, doPB;
  
  long tot_trial_num;
  float stimdurLB=0.0, stimdurUB=0.0, stimdur_range = 0.0, trialdur = 0.0;
  unsigned long int temp_dur,stimulus_duration,offset1,offset2,offset,sd;
  float latitude = 32.82, longitude = 117.14;
  time_t curr_tt, rise_tt, set_tt;
  struct timeval perchtime, good_perch, perchstart, tstart, tstop, tdur;
  struct tm *loctime;
  int target = 0, perchcheck = 0, do_trial = 0;
  int no_stim_trial = 0, tot_no_stim_trial = 0;
  int playcase;

  struct stim {
    char name [128];
    char exemplar[128];
    char cue [128];
    int class;
    int reinf;
    int freq;
    unsigned long int dur; 
    int num;
  }C1stim[MAXSTIM], C2stim[MAXSTIM],tmp;
  struct data {
    int trials;
    int j;
    float dur;
    char name[128];
  } class[MAXCLASS], stim[MAXSTIM];
  
  snd_pcm_t *activepcm;
  sigset_t trial_mask;
  
  srand (time (0) );
  
  /* set up termination handler*/
  if (signal(SIGPIPE, sig_pipe) == SIG_ERR){
    perror("error installing signal handler for SIG_PIPE");
    exit (-1);
  }
  
  sigemptyset (&trial_mask);
  sigaddset (&trial_mask, SIGINT);
  sigaddset (&trial_mask, SIGTERM);
  signal(SIGTERM, termination_handler);
  signal(SIGINT, termination_handler);
  
  
	/* Parse the command line */
        command_line_parse(argc, argv, &box_id, &subjectid, &starthour, &stophour, &startmin, &stopmin, &noiselength, &swapval,&stimfname);
       	if(DEBUG){
	  fprintf(stderr,"command_line_parse(): box_id=%d, subjectid=%d, starthour=%d, stophour=%d, startmin=%d, stopmin=%d, noiselength= %d, swapval=%d, stimfile: %s\n",
		  box_id, subjectid, starthour, stophour, startmin, stopmin, noiselength, swapval, initstate, stimfname);
	}
	/* todo: create a 3spk box. currently calling it box 1*/
	if(box_id!=1){
	  fprintf(stderr,"\n\n ***************************************************************\n");
	  fprintf(stderr,    " **  FATAL ERROR!: 3spk only runs in box 1                    **\n");
	  fprintf(stderr,    " **   (really, it can run in any box that has a 3 channel DAC **\n");
	  fprintf(stderr,    " **    line and cue lights)                                   **\n"); 
	  fprintf(stderr,  "\n ***************************************************************\n\n");
	  exit(-1);
	}

	if(DEBUG){fprintf(stderr,"commandline done, now checking for errors\n");}

	/* watch for terminal errors*/
	if( (stophour!=99) && (starthour !=99) ){
          if ((stophour <= starthour) && (stopmin<=startmin)){
            fprintf(stderr, "\tTERMINAL ERROR: exp start-time must be greater than stop-time\n");
            exit(-1);
          }
        }
	if (box_id <= 0){
	  fprintf(stderr, "\tYou must enter a box ID!\n"); 
	  fprintf(stderr, "\tERROR: try 'femxpeck -help' for available options\n");
	  exit(-1);
	}
	
	/*set some variables as needed*/
	if(DEBUG){fprintf(stderr, "starthour: %d\tstartmin: %d\tstophour: %d\tstopmin: %d\n", starthour,startmin,stophour,stopmin);}
        curr_tt = time(NULL);
        loctime = localtime (&curr_tt);
        strftime (year, 16, "%Y", loctime);
        strftime(month, 16, "%m", loctime);
        strftime(day, 16,"%d", loctime);

        if(starthour==99){
          dosunrise=1;
          rise_tt = sunrise(atoi(year), atoi(month), atoi(day), latitude, longitude);
          strftime(temphour, 16, "%H", localtime(&rise_tt));
          strftime(tempmin, 16, "%M", localtime(&rise_tt));
          starthour=atoi(temphour);
          startmin=atoi(tempmin);
          strftime(buffer,30,"%m-%d-%Y %H:%M:%S",localtime(&rise_tt));
          printf("Sessions start at sunrise (Today: '%s')\n",buffer);
        }
        if(stophour==99){
          dosunset=1;
          set_tt = sunset(atoi(year), atoi(month), atoi(day), latitude, longitude);
          strftime(temphour, 16, "%H", localtime(&set_tt));
          strftime(tempmin, 16, "%M", localtime(&set_tt));
          stophour=atoi(temphour);
          stopmin=atoi(tempmin);
          strftime(buffer,30,"%m-%d-%Y  %T",localtime(&set_tt));
          printf("Sessions stop at sunset (Today: '%s')\n",buffer);
        }

        starttime=(starthour*60)+startmin;
        stoptime=(stophour*60)+stopmin;
        if(DEBUG){fprintf(stderr, "starthour: %d\tstartmin: %d\tstophour: %d\tstopmin: %d\n", starthour,startmin,stophour,stopmin);}


	/* Initialize box */
	if(DEBUG){
	  printf("Initializing box %d ......", box_id);
	}
	if((pcm_trip = do_setup(TRIP_PCM))<0){
	  fprintf(stderr,"FAILED to set up the pcm device %s\n", TRIP_PCM);
	  exit (-1);
	}
	if (operant_open()!=0){
	  fprintf(stderr, "Problem opening IO interface\n");
	  snd_pcm_close(pcm_trip);
	  exit (-1);
	}
	if(DEBUG){fprintf(stderr, "pcm_trip handle: %d",(int)pcm_trip};
	
	operant_clear(box_id);
	if(DEBUG){fprintf(stderr, "box intialized!\n");}

	/* give user some feedback*/
	fprintf(stderr, "Loading stimuli from file '%s' for session in box '%d' \n", stimfname, box_id); 
	fprintf(stderr, "Subject ID number: %i\n", subjectid);
	/* remember stim file setup: 'class exemplar cue frequency' */
	/* class 1 = masker, class 2 = target/distractors */
	/* if masker = online noise, exemplar filename should be 'noise' */
	/* cue is either wav file or RED GRN BLU */


	/* Read in the list of exemplars */
	nstims = num_c1stims = num_c2stims = 0;
	nclasses=0;
	if ((stimfp = fopen(stimfname, "r")) != NULL){
	  while (fgets(buf, sizeof(buf), stimfp))
	    nstims++;
	  fprintf(stderr, "Found %d stimulus exemplars in '%s'\n", nstims, stimfname);
	  rewind(stimfp);
	

	  for (i = 0; i < nstims; i++){
	    fgets(buf, 128, stimfp);
	    temp_dur=0;
	    sscanf(buf, "\n\n%d\%s\%s\%d", &tmp.class, tmp.exemplar, tmp.cue &tmp.freq);
	    if(DEBUG){fprintf(stderr, "%d %s %s %d\n", tmp.class, tmp.exemplar, tmp.cue, tmp.freq);}
	    if(tmp.freq==0){
	      printf("ERROR: insufficnet data or bad format in '.stim' file. Try '3spk -help'\n");
	      exit(0);} 
	    /* count stimulus classes*/
	    if (nclasses<tmp.class){nclasses=tmp.class;}
	    if (DEBUG){printf("nclasses set to: %d\n", nclasses);}
	    if(tmp.class>2)
	      fprintf(stderr, "stimulus '%s' has an invalid class. Must be 1 or 2.\n", tmp.exemplar);	    
               	    
	    /*verify the stimulus soundfile, if not online noise*/
	    if (strncmp(tmp.exemplar, 'noise', 5) != 0){
	      sprintf(fullsfname,"%s%s", STIMPATH, tmp.exemplar);          /* add full path to stim file name */
	      if(DEBUG){printf("trying to verify %s\n",fullsfname);}
	      if((temp_dur = verify_soundfile(fullsfname))<1){
		fprintf(stderr, "Unable to verify %s!\n",fullsfname );  
		snd_pcm_close(pcm_trip);
		exit(0); 
	      }	    
	      if(DEBUG){printf("soundfile %s verified, duration: %lu\n", tmp.exemplar, temp_dur);}
	      strcpy (stim[i].name, tmp.exemplar);	    
	    }

	    /*verify the cue soundfile, if audio cue*/
	    if (strlen(tmp.cue)> 3){
	      sprintf(fullcfname,"%s%s", STIMPATH, tmp.cue);               /* add full path to cue file name */    
	      if(DEBUG){printf("trying to verify %s\n",fullsfname);}
	      if((temp_dur = verify_soundfile(fullsfname))<1){
		fprintf(stderr, "Unable to verify %s!\n",fullsfname );  
		snd_pcm_close(pcm_trip);
		exit(0); 
	      }
	      if(DEBUG){printf("soundfile %s verified, duration: %lu\n", tmp.exemplar, temp_dur);}
	    }
	    strcpy (stim[i].name, tmp.exemplar);
	    switch(tmp.class){
	    case 1:
	      if (DEBUG){printf("adding class 1 soundfile to stimlist\n");}
	      num_c1stims++;
	      C1stim[num_c1stims-1].class = tmp.class;
	      strcpy (C1stim[num_c1stims-1].exemplar, tmp.exemplar);
	      C1stim[num_c1stims-1].freq = tmp.freq;
	      C1stim[num_c1stims-1].dur = temp_dur;
	      C1stim[num_c1stims-1].num = i;
	      tot_c1stims += C1stim[num_c1stims-1].freq;
	      break;
	    case 2:
	      if (DEBUG){printf("adding class 2 soundfile to stimlist\n");}
	      num_c2stims++;
	      C2stim[num_c2stims-1].class = tmp.class;
	      strcpy (C2stim[num_c2stims-1].exemplar, tmp.exemplar);
	      strcpy (C2stim[num_c2stims-1].cue, tmp.cue);
	      C2stim[num_c2stims-1].freq = tmp.freq;
	      C2stim[num_c2stims-1].dur = temp_dur;
	      C2stim[num_c2stims-1].num = i;
	      tot_c2stims += C2stim[num_c2stims-1].freq;
	      break;
	    }
	    if(DEBUG){printf("class1 stims: %d \ttotal c1stims: %d\n", num_c1stims, tot_c1stims);}
	    if(DEBUG){printf("class2 stims: %d \ttotal c2stims: %d\n", num_c2stims, tot_c2stims);}
	  }
	}
	else{ 
	  printf("Error opening stimulus input file! Try '3spk -help' for proper file formatting.\n");  
	   snd_pcm_close(pcm_left); snd_pcm_close(pcm_center); snd_pcm_close(pcm_right);
	  exit(0);	  
	}
	fclose(stimfp);
	if(DEBUG){printf("Done reading in stims; %d stims in %d classes found\n", nstims, nclasses);}

	if(DEBUG){
	  for(i=0;i<num_c1stims;i++){
	    printf("c1:%d\tclass:%d\tname:%s\tfreq:%d\tdur:%lu\n", i, C1stim[i].class, C1stim[i].exemplar, 
		   C1stim[i].freq, C1stim[i].dur);}
	  for(i=0;i<num_c2stims;i++){
	    printf("c2:%d\tclass:%d\tname:%s\tcue:%s\tfreq:%d\tdur:%lu\n", i, C2stim[i].class, C2stim[i].exemplar, 
		   C2stim[i].cue, C2stim[i].freq, C2stim[i].dur);}
	}

	/* build the stimulus playlists */
	if(DEBUG){printf("Making the playlist for stimclass 1\n");}
	free(C1_plist);
	C1_plist = malloc( (tot_c1stims+1)*sizeof(int) );
	i=j=0;
	for (i=0;i<num_c1stims; i++){
	  k=0;
	  for(k=0;k<C1stim[i].freq;k++){
	    C1_plist[j]=i;
	    if(DEBUG){printf("value for class 1 playlist entry '%d' is '%d'\n", j, i);}
	    j++;
	  }
	}

	if(DEBUG){printf("Making the playlist for stimclass 2\n");}
	free(C2_plist);
	C2_plist = malloc( (tot_c2stims+1)*sizeof(int) );
	i=j=0;
	for (i=0;i<num_c2stims; i++){
	  k=0;
	  for(k=0;k<C2stim[i].freq;k++){
	    C2_plist[j]=i;
	    if(DEBUG){printf("value for class 2 playlist entry '%d' is '%d'\n", j, i);}
	    j++;
	  }
	}

	/*zero out the stimulus and class data counters*/
	for(i = 0; i<nstims;++i)
	  stim[i].trials = stim[i].dur = 0;
	if (DEBUG){printf("stimulus counters zeroed!\n");} 
	for(i=0;i<nclasses;i++)
	  class[i].trials = class[i].dur = 0;
	if (DEBUG){printf("class counters zeroed!\n");} 
	strcpy(class[0].name, "silence");
	strcpy(class[1].name, "class1"); 
	strcpy(class[2].name, "class2");	
	
	/*  Open & setup data logging files */
	curr_tt = time (NULL);
	loctime = localtime (&curr_tt);
	strftime (timebuff, 64, "%d%b%y", loctime);
	sprintf (stimftemp, "%s", stimfname);
	stimfroot = strtok (stimftemp, delimiters); 
	sprintf(datafname, "%i_%s.3spk_rDAT", subjectid, stimfroot);
	sprintf(dsumfname, "%i.summaryDAT", subjectid);
	datafp = fopen(datafname, "a");
        dsumfp = fopen(dsumfname, "w");
	
	if ( (datafp==NULL) || (dsumfp==NULL) ){
          fprintf(stderr, "ERROR!: problem opening data output file!: %s\n", datafname);
	  snd_pcm_close(pcm_left); snd_pcm_close(pcm_center); snd_pcm_close(pcm_right);
	  fclose(datafp);
	  fclose(dsumfp);
	  exit(-1);
        }

	/* Write data file header info */
	printf ("Data output to '%s'\n", datafname);
	fprintf (datafp, "File name: %s\n", datafname);
	fprintf (datafp, "Procedure source: %s\n", exp_name);
	fprintf (datafp, "Start time: %s", asctime(loctime));
	fprintf (datafp, "Subject ID: %d\n", subjectid);
	fprintf (datafp, "Stimulus source: %s\n", stimfname);  
	fprintf (datafp, "Sess#\ttTrl#\tsTrl#\tSwap\tStimulus\tCue\tMasker\tTrl_dur\tTOD\tDate\n");


   /********************************************     
    +++++++++++ Trial sequence ++++++++++++++
   ********************************************/
	session_num = 1;
	trial_num = 0;
	rswap = 0; swapcnt = 1;
	tot_trial_num = 0;
	tot_no_stim_trial=0;
	no_stim_trial=0;
	
	curr_tt = time(NULL);
	loctime = localtime (&curr_tt);
	strftime (hour, 16, "%H", loctime);
	if (DEBUG){printf("atoi(hour) at loop start: %d \n", atoi(hour));}

	curr_tt = time(NULL);
        loctime = localtime (&curr_tt);
        strftime (hour, 16, "%H", loctime);
        strftime(min, 16, "%M", loctime);
        if (DEBUG){printf("hour:min at loop start: %d:%d \n", atoi(hour),atoi(min));}
        currtime=(atoi(hour)*60)+atoi(min);

	operant_write (box_id, HOUSELT, 1);        /* make sure houselight is on */

	do{                                                                               /* start the block loop */
	  while((currtime>=starttime) && (currtime<stoptime)){
	    if(DEBUG){printf("\n\n ***********\n TRIAL START\n");}
	    if (DEBUG==2){printf("minutes since midnight at loop start: %d\t starttime: %d\tstoptime: %d\n",
                              currtime,starttime,stoptime);}
	    
	    /*cue three randomly chosen stimulus source files: one masker from c1 playlist, one target and one distractor from c2 playlist */
	    srand(time(0));
	    C1_pval = (int) ((tot_c1stims+0.0)*rand()/(RAND_MAX+0.0));        /* select playlist1 entry at random */ 
	    C2t_pval = (int) ((tot_c2stims+0.0)*rand()/(RAND_MAX+0.0));       /* select target playlist2 entry at random */ 
	    C2d_pval = (int) ((tot_cstims+0.0)*rand()/(RAND_MAX+0.0));        /* select distractor playlist2 entry at random */ 
	    while (C2b_pval==C2a_pval)                                        /* if targ and dist are the same, reselect distractor until different*/
	      C2b_pval = (int) ((tot_cstims+0.0)*rand()/(RAND_MAX+0.0));
	    C1_stim_number = C1_plist[C1_pval];
	    C2t_stim_number = C2_plist[C2t_pval];
	    C2d_stim_number = C2_plist[C2d_pval];
	    if (DEBUG){printf("cued stim for c1: %s\t c2: %s\n", C1stim[C1_stim_number].exemplar, C2stim[C2_stim_number].exemplar);} 
	    
	
	    /* todo: make do_trial depend on keypeck */

	    if(do_trial){
	      ++trial_num;++tot_trial_num;
	      /*set your trial variables*/
	      /* todo: rewrite stim file structure and select stimuli randomly */
	      stimulus_duration = sd;
	      stim_class = C1stim[C1_stim_number].class;                              
	      strcpy (stimexm, C1stim[C1_stim_number].exemplar);                      
	      stim_reinf = C1stim[C1_stim_number].reinf;
	      stim_num = C1stim[C1_stim_number].num;
	      sprintf(fstim,"%s%s", STIMPATH, stimexm); 
	      activepcm = aud1;
	      doPB=1; /* what is doPB?? */
		
	      if(DEBUG){
		printf("stim class: %d\t", stim_class);
		printf("stimulus file name: %s\n", stimexm);
	      }
		
	      sigprocmask (SIG_BLOCK, &trial_mask, NULL);     /* block termination signals*/
	      /* todo: set masker, target,distractor*/
	      int masker = 0;
	      int target = 0;
	      int distract = 0;

	      /* todo: determine value of playcase (int 1:9) */


	      /* Play stimulus file */
	      gettimeofday(&tstart, NULL);
	      if(DEBUG){printf("****** STARTING %s PLAYBACK ....\t", stimexm);}
	      if(doPB){
		if (play_3stereo(pcm_trip, masker, target, distract, playcase, box_id, noiselength)!=1){
		  fprintf(stderr, "play_and_watch error on stimfile:%s. Program aborted %s\n", 
			  stimexm, asctime(localtime (&curr_tt)) );
		  fprintf(datafp, "play_and_watch error on stimfile:%s. Program aborted %s\n", 
			  stimexm, asctime(localtime (&curr_tt)) );
		  fclose(datafp);
		  fclose(dsumfp); 
		  snd_pcm_close(pcm_left); snd_pcm_close(pcm_center); snd_pcm_close(pcm_right);
		  exit(-1);
		}
	      }
	      if (DEBUG){printf("PLAYBACK COMPLETE\n");}

	      /* correct or incorrect */

	      /* note time that trial ends */
	      curr_tt = time (NULL); 
	      loctime = localtime (&curr_tt);                     /* date and wall clock time of trial*/
	      strftime (hour, 16, "%H", loctime);                    /* format wall clock times */
	      strftime (min, 16, "%M", loctime);
	      strftime (month, 16, "%m", loctime);
	      strftime (day, 16, "%d", loctime);
	      currtime=(atoi(hour)*60)+atoi(min);
	      
	      /*update the data counters*/
	      ++class[stim_class].trials; 
	      class[stim_class].dur += trialdur;
	      if(doPB){
		++stim[stim_num].trials; 
		stim[stim_num].dur += trialdur; 
		++swapcnt;
	      }
	      else{
		++no_stim_trial;
		++tot_no_stim_trial;
	      }
	      
	      /* Pause for ITI */
	      operant_write(box_id, HOUSELT, 1);         /* make sure the houselight is on */
	      nanosleep(&iti, NULL);                     /* wait intertrial interval */
	      if (DEBUG){printf("ITI passed\n");}
	      
	      /* Write trial data to output file */
	      strftime (tod, 256, "%H%M", loctime);
	      strftime (date_out, 256, "%m%d", loctime);
	      fprintf(datafp, "%d\t%lu\t%d\t%d\t%s\t%lu\t%lu\t%d\t%.4f\t%s\t%s\n",
		      session_num,tot_trial_num,trial_num,rswap,stimexm,offset,stimulus_duration,stim_class,trialdur,tod,date_out );
	      fflush (datafp);
	      if (DEBUG){
		printf("%d\t%lu\t%d\t%d\t%s\t%lu\t%lu\t%d\t%.4f\t%s\t%s\n", 
		       session_num,tot_trial_num,trial_num,rswap,stimexm,offset,stimulus_duration,stim_class,trialdur,tod,date_out );
	      }

	      
	      /* Update summary data */ 
	      if(freopen(dsumfname,"w",dsumfp)!= NULL){
		fprintf (dsumfp, "          SUMMARY DATA FOR st%d, %s\n", subjectid, exp_name); 
		fprintf (dsumfp, "SESSION TOTALS BY STIMULUS CLASS\n\n");
		fprintf (dsumfp, "\t\tClass \tTrials \tDuration\n");
		for (i = 0; i<=nclasses;++i){
		  fprintf (dsumfp, "\t\t%s  \t %d    \t %.4f\n", 
			   class[i].name, class[i].trials, class[i].dur);
		}
	      
		fprintf (dsumfp, "\n\n\n\tSESSION TOTALS BY SOURCE SOUNDFILE\n");
		fprintf (dsumfp, "\t\tSoundfile \tTrials \tDuration\n");
		for (i = 0; i<nstims;++i){
		  fprintf (dsumfp, "\t\t%s  \t %d    \t %.4f\n", 
			   stim[i].name, stim[i].trials, stim[i].dur);
		}
		
		fprintf (dsumfp, "\n\n\nLast trial run @: %s\n", asctime(loctime) );
		fprintf (dsumfp, "Trials this session: %d\n",trial_num);
		fflush (dsumfp);
		
	      }
	      else
		fprintf(stderr, "ERROR!: problem re-opening summary output file!: %s\n", dsumfname);
	      
	      if (DEBUG){printf("trial summaries updated\n");}
	      
	      
	      /* End of trial chores */
	      sigprocmask (SIG_UNBLOCK, &trial_mask, NULL);        /* unblock termination signals */ 
	      C1_stim_number = C2_stim_number = -1;                /* reset the stim number for correct trial*/
	      if (DEBUG){printf("****end of trial\n\t swapcount:%d\tswapval:%d\trswap:%d\n",swapcnt,swapval,rswap);}
	      if(swapcnt==swapval){                                /*check if you should swap the stim-resp pairings */ 
		if (DEBUG){printf("swapped the contingencies\n");}
		if(mapval){
		  do_mappings(initstate-1); 
		  mapval=0;
		}
		else{ 
		  do_mappings(initstate+1);
		  mapval=1;
		}
		if(rswap) rswap=0; else rswap=1;
		swapcnt=1;
	      }
	      if(DEBUG){printf("minutes since midnight at end of trial: %d\n", currtime);}
	    }
	  }                                  /*  trial loop */
	  
	  curr_tt = time (NULL);
	  loctime = localtime (&curr_tt);
	  strftime (hour, 16, "%H", loctime);
	  strftime(min, 16, "%M", loctime);
	  currtime=(atoi(hour)*60)+atoi(min);
	  if (DEBUG){printf("minutes since midnight at trial loop exit end: %d\t starttime: %d\tstoptime: %d\n",currtime,starttime,stoptime);}
	  
	  /* Loop while lights out */
	  while( (currtime<starttime) || (currtime>=stoptime) ){
	    operant_write(box_id, HOUSELT, 0);
	    sleep (sleep_interval);
	    curr_tt = time(NULL);
            loctime = localtime (&curr_tt);
            strftime (hour, 16, "%H", loctime);
            strftime (min, 16, "%M", loctime);
            currtime=(atoi(hour)*60)+atoi(min);
            if (DEBUG){printf("minutes since midnight: %d\t starttime: %d\tstoptime: %d\n",currtime,starttime,stoptime);}
	  }
	  operant_write(box_id, HOUSELT, 1);
	  ++session_num;
	  trial_num = 0;
	  no_stim_trial=0;

	  if (DEBUG){printf("swapcount:%d\tswapval:%d\trswap:%d\n",swapcnt,swapval,rswap);}
	  if(swapval==0){                            /*check if we need to swap the stim-perch pairings for the new session */	
	    if(mapval){
	      do_mappings(initstate-1); 
	      mapval=0;
	    }
	    else{
	      do_mappings(initstate+1);
	      mapval=1;
	    }
	    if(rswap) rswap=0; else rswap=1;
	    swapcnt=0; 
	  }
	  

	}while (1);// main loop
	
	curr_tt = time(NULL);
	
	
	/*  Cleanup */
	fclose(datafp);
	fclose(dsumfp);
	snd_pcm_close(pcm_left); snd_pcm_close(pcm_center); snd_pcm_close(pcm_right);
	return 0;
}                         

